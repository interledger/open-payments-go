// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"encoding/json"
	"fmt"
)

// Defines values for JsonWebKeyAlg.
const (
	EdDSA JsonWebKeyAlg = "EdDSA"
)

// Defines values for JsonWebKeyCrv.
const (
	Ed25519 JsonWebKeyCrv = "Ed25519"
)

// Defines values for JsonWebKeyKty.
const (
	OKP JsonWebKeyKty = "OKP"
)

// Defines values for JsonWebKeyUse.
const (
	Sig JsonWebKeyUse = "sig"
)

// DidDocument A DID Document using JSON encoding
type DidDocument map[string]interface{}

// JsonWebKey A JWK representation of an Ed25519 Public Key
type JsonWebKey struct {
	// Alg The cryptographic algorithm family used with the key. The only allowed value is `EdDSA`.
	Alg JsonWebKeyAlg  `json:"alg"`
	Crv JsonWebKeyCrv  `json:"crv"`
	Kid string         `json:"kid"`
	Kty JsonWebKeyKty  `json:"kty"`
	Use *JsonWebKeyUse `json:"use,omitempty"`

	// X The base64 url-encoded public key.
	X string `json:"x"`
}

// JsonWebKeyAlg The cryptographic algorithm family used with the key. The only allowed value is `EdDSA`.
type JsonWebKeyAlg string

// JsonWebKeyCrv defines model for JsonWebKey.Crv.
type JsonWebKeyCrv string

// JsonWebKeyKty defines model for JsonWebKey.Kty.
type JsonWebKeyKty string

// JsonWebKeyUse defines model for JsonWebKey.Use.
type JsonWebKeyUse string

// JsonWebKeySet A JSON Web Key Set document according to [rfc7517](https://datatracker.ietf.org/doc/html/rfc7517) listing the keys associated with this wallet address. These keys are used to sign requests made by this wallet address.
type JsonWebKeySet struct {
	Keys *[]JsonWebKey `json:"keys,omitempty"`
}

// WalletAddress A **wallet address** resource is the root of the API and contains the public details of the financial account represented by the Wallet Address that is also the service endpoint URL.
type WalletAddress struct {
	// AssetCode The assetCode is a code that indicates the underlying asset. An ISO4217 currency code should be used whenever possible. The ISO4217 representation of the US Dollar is USD.
	AssetCode string `json:"assetCode"`

	// AssetScale The number of decimal places that defines the scale of the smallest divisible unit for the given asset code. It determines how an integer amount is scaled to derive the actual monetary value. For example, USD has an asset scale of 2 with the smallest unit being 0.01. An integer amount of `1000` with an `assetCode` of `USD` and `assetScale` of `2` translates to $10.00.
	AssetScale int `json:"assetScale"`

	// AuthServer The URL of the authorization server endpoint for getting grants and access tokens for this wallet address.
	AuthServer *string `json:"authServer,omitempty"`

	// Id The URL identifying the wallet address.
	Id *string `json:"id,omitempty"`

	// PublicName A public name for the account. This should be set by the account holder with their provider to provide a hint to counterparties as to the identity of the account holder.
	PublicName *string `json:"publicName,omitempty"`

	// ResourceServer The URL of the resource server endpoint for performing Open Payments with this wallet address.
	ResourceServer       *string                `json:"resourceServer,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Getter for additional properties for WalletAddress. Returns the specified
// element and whether it was found
func (a WalletAddress) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WalletAddress
func (a *WalletAddress) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WalletAddress to handle AdditionalProperties
func (a *WalletAddress) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["assetCode"]; found {
		err = json.Unmarshal(raw, &a.AssetCode)
		if err != nil {
			return fmt.Errorf("error reading 'assetCode': %w", err)
		}
		delete(object, "assetCode")
	}

	if raw, found := object["assetScale"]; found {
		err = json.Unmarshal(raw, &a.AssetScale)
		if err != nil {
			return fmt.Errorf("error reading 'assetScale': %w", err)
		}
		delete(object, "assetScale")
	}

	if raw, found := object["authServer"]; found {
		err = json.Unmarshal(raw, &a.AuthServer)
		if err != nil {
			return fmt.Errorf("error reading 'authServer': %w", err)
		}
		delete(object, "authServer")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["publicName"]; found {
		err = json.Unmarshal(raw, &a.PublicName)
		if err != nil {
			return fmt.Errorf("error reading 'publicName': %w", err)
		}
		delete(object, "publicName")
	}

	if raw, found := object["resourceServer"]; found {
		err = json.Unmarshal(raw, &a.ResourceServer)
		if err != nil {
			return fmt.Errorf("error reading 'resourceServer': %w", err)
		}
		delete(object, "resourceServer")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WalletAddress to handle AdditionalProperties
func (a WalletAddress) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["assetCode"], err = json.Marshal(a.AssetCode)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'assetCode': %w", err)
	}

	object["assetScale"], err = json.Marshal(a.AssetScale)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'assetScale': %w", err)
	}

	object["authServer"], err = json.Marshal(a.AuthServer)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'authServer': %w", err)
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.PublicName != nil {
		object["publicName"], err = json.Marshal(a.PublicName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'publicName': %w", err)
		}
	}

	object["resourceServer"], err = json.Marshal(a.ResourceServer)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'resourceServer': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
