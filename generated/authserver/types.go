// Package authserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package authserver

import (
	"encoding/json"
	"fmt"

	externalRef0 "github.com/interledger/open-payments-go/generated/schemas"
	"github.com/oapi-codegen/runtime"
)

const (
	GNAPScopes = "GNAP.Scopes"
)

// Defines values for AccessIncomingActions.
const (
	AccessIncomingActionsComplete AccessIncomingActions = "complete"
	AccessIncomingActionsCreate   AccessIncomingActions = "create"
	AccessIncomingActionsList     AccessIncomingActions = "list"
	AccessIncomingActionsListAll  AccessIncomingActions = "list-all"
	AccessIncomingActionsRead     AccessIncomingActions = "read"
	AccessIncomingActionsReadAll  AccessIncomingActions = "read-all"
)

// Defines values for AccessIncomingType.
const (
	IncomingPayment AccessIncomingType = "incoming-payment"
)

// Defines values for AccessOutgoingActions.
const (
	AccessOutgoingActionsCreate  AccessOutgoingActions = "create"
	AccessOutgoingActionsList    AccessOutgoingActions = "list"
	AccessOutgoingActionsListAll AccessOutgoingActions = "list-all"
	AccessOutgoingActionsRead    AccessOutgoingActions = "read"
	AccessOutgoingActionsReadAll AccessOutgoingActions = "read-all"
)

// Defines values for AccessOutgoingType.
const (
	OutgoingPayment AccessOutgoingType = "outgoing-payment"
)

// Defines values for AccessQuoteActions.
const (
	Create  AccessQuoteActions = "create"
	Read    AccessQuoteActions = "read"
	ReadAll AccessQuoteActions = "read-all"
)

// Defines values for AccessQuoteType.
const (
	Quote AccessQuoteType = "quote"
)

// Defines values for InteractRequestFinishMethod.
const (
	InteractRequestFinishMethodRedirect InteractRequestFinishMethod = "redirect"
)

// Defines values for InteractRequestStart.
const (
	InteractRequestStartRedirect InteractRequestStart = "redirect"
)

// Access A description of the rights associated with this access token.
type Access = []AccessItem

// AccessIncoming defines model for access-incoming.
type AccessIncoming struct {
	// Actions The types of actions the client instance will take at the RS as an array of strings.
	Actions []AccessIncomingActions `json:"actions"`

	// Identifier A string identifier indicating a specific resource at the RS.
	Identifier *string `json:"identifier,omitempty"`

	// Type The type of resource request as a string.  This field defines which other fields are allowed in the request object.
	Type AccessIncomingType `json:"type"`
}

// AccessIncomingActions defines model for AccessIncoming.Actions.
type AccessIncomingActions string

// AccessIncomingType The type of resource request as a string.  This field defines which other fields are allowed in the request object.
type AccessIncomingType string

// AccessItem The access associated with the access token is described using objects that each contain multiple dimensions of access.
type AccessItem struct {
	union json.RawMessage
}

// AccessOutgoing defines model for access-outgoing.
type AccessOutgoing struct {
	// Actions The types of actions the client instance will take at the RS as an array of strings.
	Actions []AccessOutgoingActions `json:"actions"`

	// Identifier A string identifier indicating a specific resource at the RS.
	Identifier string `json:"identifier"`

	// Limits Open Payments specific property that defines the limits under which outgoing payments can be created.
	Limits *LimitsOutgoing `json:"limits,omitempty"`

	// Type The type of resource request as a string.  This field defines which other fields are allowed in the request object.
	Type AccessOutgoingType `json:"type"`
}

// AccessOutgoingActions defines model for AccessOutgoing.Actions.
type AccessOutgoingActions string

// AccessOutgoingType The type of resource request as a string.  This field defines which other fields are allowed in the request object.
type AccessOutgoingType string

// AccessQuote defines model for access-quote.
type AccessQuote struct {
	// Actions The types of actions the client instance will take at the RS as an array of strings.
	Actions []AccessQuoteActions `json:"actions"`

	// Type The type of resource request as a string.  This field defines which other fields are allowed in the request object.
	Type AccessQuoteType `json:"type"`
}

// AccessQuoteActions defines model for AccessQuote.Actions.
type AccessQuoteActions string

// AccessQuoteType The type of resource request as a string.  This field defines which other fields are allowed in the request object.
type AccessQuoteType string

// AccessToken A single access token or set of access tokens that the client instance can use to call the RS on behalf of the RO.
type AccessToken struct {
	// Access A description of the rights associated with this access token.
	Access Access `json:"access"`

	// ExpiresIn The number of seconds in which the access will expire.  The client instance MUST NOT use the access token past this time.  An RS MUST NOT accept an access token past this time.
	ExpiresIn *int `json:"expires_in,omitempty"`

	// Manage The management URI for this access token. This URI MUST NOT include the access token value and SHOULD be different for each access token issued in a request.
	Manage string `json:"manage"`

	// Value The value of the access token as a string.  The value is opaque to the client instance.  The value SHOULD be limited to ASCII characters to facilitate transmission over HTTP headers within other protocols without requiring additional encoding.
	Value string `json:"value"`
}

// Client Wallet address of the client instance that is making this request.
//
// When sending a non-continuation request to the AS, the client instance MUST identify itself by including the client field of the request and by signing the request.
//
// A JSON Web Key Set document, including the public key that the client instance will use to protect this request and any continuation requests at the AS and any user-facing information about the client instance used in interactions, MUST be available at the wallet address + `/jwks.json` url.
//
// If sending a grant initiation request that requires RO interaction, the wallet address MUST serve necessary client display information.
type Client = string

// Continue If the AS determines that the request can be continued with additional requests, it responds with the continue field.
type Continue struct {
	// AccessToken A unique access token for continuing the request, called the "continuation access token".
	AccessToken struct {
		Value string `json:"value"`
	} `json:"access_token"`

	// Uri The URI at which the client instance can make continuation requests.
	Uri string `json:"uri"`

	// Wait The amount of time in integer seconds the client instance MUST wait after receiving this request continuation response and calling the continuation URI.
	Wait *int `json:"wait,omitempty"`
}

// InteractRequest The client instance declares the parameters for interaction methods that it can support using the interact field.
type InteractRequest struct {
	// Finish Indicates how the client instance can receive an indication that interaction has finished at the AS.
	Finish *struct {
		// Method The callback method that the AS will use to contact the client instance.
		Method InteractRequestFinishMethod `json:"method"`

		// Nonce Unique value to be used in the calculation of the "hash" query parameter sent to the callback URI, must be sufficiently random to be unguessable by an attacker.  MUST be generated by the client instance as a unique value for this request.
		Nonce string `json:"nonce"`

		// Uri Indicates the URI that the AS will either send the RO to after interaction or send an HTTP POST request.
		Uri string `json:"uri"`
	} `json:"finish,omitempty"`

	// Start Indicates how the client instance can start an interaction.
	Start []InteractRequestStart `json:"start"`
}

// InteractRequestFinishMethod The callback method that the AS will use to contact the client instance.
type InteractRequestFinishMethod string

// InteractRequestStart defines model for InteractRequest.Start.
type InteractRequestStart string

// InteractResponse defines model for interact-response.
type InteractResponse struct {
	// Finish Unique key to secure the callback.
	Finish string `json:"finish"`

	// Redirect The URI to direct the end user to.
	Redirect string `json:"redirect"`
}

// Interval [ISO8601 repeating interval](https://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals)
type Interval = string

// LimitsOutgoing Open Payments specific property that defines the limits under which outgoing payments can be created.
type LimitsOutgoing struct {
	DebitAmount *externalRef0.Amount `json:"debitAmount,omitempty"`

	// Interval [ISO8601 repeating interval](https://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals)
	Interval      *Interval            `json:"interval,omitempty"`
	ReceiveAmount *externalRef0.Amount `json:"receiveAmount,omitempty"`

	// Receiver The URL of the incoming payment or ILP STREAM connection that is being paid.
	Receiver *externalRef0.Receiver `json:"receiver,omitempty"`
	union    json.RawMessage
}

// LimitsOutgoing0 defines model for .
type LimitsOutgoing0 = interface{}

// LimitsOutgoing1 defines model for .
type LimitsOutgoing1 = interface{}

// LimitsOutgoing2 defines model for .
type LimitsOutgoing2 = interface{}

// PostRequestJSONBody defines parameters for PostRequest.
type PostRequestJSONBody struct {
	AccessToken struct {
		// Access A description of the rights associated with this access token.
		Access Access `json:"access"`
	} `json:"access_token"`

	// Client Wallet address of the client instance that is making this request.
	//
	// When sending a non-continuation request to the AS, the client instance MUST identify itself by including the client field of the request and by signing the request.
	//
	// A JSON Web Key Set document, including the public key that the client instance will use to protect this request and any continuation requests at the AS and any user-facing information about the client instance used in interactions, MUST be available at the wallet address + `/jwks.json` url.
	//
	// If sending a grant initiation request that requires RO interaction, the wallet address MUST serve necessary client display information.
	Client Client `json:"client"`

	// Interact The client instance declares the parameters for interaction methods that it can support using the interact field.
	Interact *InteractRequest `json:"interact,omitempty"`
}

// PostContinueJSONBody defines parameters for PostContinue.
type PostContinueJSONBody struct {
	// InteractRef The interaction reference generated for this
	// interaction by the AS.
	InteractRef string `json:"interact_ref"`
}

// PostRequestJSONRequestBody defines body for PostRequest for application/json ContentType.
type PostRequestJSONRequestBody PostRequestJSONBody

// PostContinueJSONRequestBody defines body for PostContinue for application/json ContentType.
type PostContinueJSONRequestBody PostContinueJSONBody

// AsAccessIncoming returns the union data inside the AccessItem as a AccessIncoming
func (t AccessItem) AsAccessIncoming() (AccessIncoming, error) {
	var body AccessIncoming
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessIncoming overwrites any union data inside the AccessItem as the provided AccessIncoming
func (t *AccessItem) FromAccessIncoming(v AccessIncoming) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessIncoming performs a merge with any union data inside the AccessItem, using the provided AccessIncoming
func (t *AccessItem) MergeAccessIncoming(v AccessIncoming) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAccessOutgoing returns the union data inside the AccessItem as a AccessOutgoing
func (t AccessItem) AsAccessOutgoing() (AccessOutgoing, error) {
	var body AccessOutgoing
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessOutgoing overwrites any union data inside the AccessItem as the provided AccessOutgoing
func (t *AccessItem) FromAccessOutgoing(v AccessOutgoing) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessOutgoing performs a merge with any union data inside the AccessItem, using the provided AccessOutgoing
func (t *AccessItem) MergeAccessOutgoing(v AccessOutgoing) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAccessQuote returns the union data inside the AccessItem as a AccessQuote
func (t AccessItem) AsAccessQuote() (AccessQuote, error) {
	var body AccessQuote
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAccessQuote overwrites any union data inside the AccessItem as the provided AccessQuote
func (t *AccessItem) FromAccessQuote(v AccessQuote) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAccessQuote performs a merge with any union data inside the AccessItem, using the provided AccessQuote
func (t *AccessItem) MergeAccessQuote(v AccessQuote) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AccessItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AccessItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLimitsOutgoing0 returns the union data inside the LimitsOutgoing as a LimitsOutgoing0
func (t LimitsOutgoing) AsLimitsOutgoing0() (LimitsOutgoing0, error) {
	var body LimitsOutgoing0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLimitsOutgoing0 overwrites any union data inside the LimitsOutgoing as the provided LimitsOutgoing0
func (t *LimitsOutgoing) FromLimitsOutgoing0(v LimitsOutgoing0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLimitsOutgoing0 performs a merge with any union data inside the LimitsOutgoing, using the provided LimitsOutgoing0
func (t *LimitsOutgoing) MergeLimitsOutgoing0(v LimitsOutgoing0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLimitsOutgoing1 returns the union data inside the LimitsOutgoing as a LimitsOutgoing1
func (t LimitsOutgoing) AsLimitsOutgoing1() (LimitsOutgoing1, error) {
	var body LimitsOutgoing1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLimitsOutgoing1 overwrites any union data inside the LimitsOutgoing as the provided LimitsOutgoing1
func (t *LimitsOutgoing) FromLimitsOutgoing1(v LimitsOutgoing1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLimitsOutgoing1 performs a merge with any union data inside the LimitsOutgoing, using the provided LimitsOutgoing1
func (t *LimitsOutgoing) MergeLimitsOutgoing1(v LimitsOutgoing1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLimitsOutgoing2 returns the union data inside the LimitsOutgoing as a LimitsOutgoing2
func (t LimitsOutgoing) AsLimitsOutgoing2() (LimitsOutgoing2, error) {
	var body LimitsOutgoing2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLimitsOutgoing2 overwrites any union data inside the LimitsOutgoing as the provided LimitsOutgoing2
func (t *LimitsOutgoing) FromLimitsOutgoing2(v LimitsOutgoing2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLimitsOutgoing2 performs a merge with any union data inside the LimitsOutgoing, using the provided LimitsOutgoing2
func (t *LimitsOutgoing) MergeLimitsOutgoing2(v LimitsOutgoing2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t LimitsOutgoing) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DebitAmount != nil {
		object["debitAmount"], err = json.Marshal(t.DebitAmount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'debitAmount': %w", err)
		}
	}

	if t.Interval != nil {
		object["interval"], err = json.Marshal(t.Interval)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'interval': %w", err)
		}
	}

	if t.ReceiveAmount != nil {
		object["receiveAmount"], err = json.Marshal(t.ReceiveAmount)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'receiveAmount': %w", err)
		}
	}

	if t.Receiver != nil {
		object["receiver"], err = json.Marshal(t.Receiver)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'receiver': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *LimitsOutgoing) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["debitAmount"]; found {
		err = json.Unmarshal(raw, &t.DebitAmount)
		if err != nil {
			return fmt.Errorf("error reading 'debitAmount': %w", err)
		}
	}

	if raw, found := object["interval"]; found {
		err = json.Unmarshal(raw, &t.Interval)
		if err != nil {
			return fmt.Errorf("error reading 'interval': %w", err)
		}
	}

	if raw, found := object["receiveAmount"]; found {
		err = json.Unmarshal(raw, &t.ReceiveAmount)
		if err != nil {
			return fmt.Errorf("error reading 'receiveAmount': %w", err)
		}
	}

	if raw, found := object["receiver"]; found {
		err = json.Unmarshal(raw, &t.Receiver)
		if err != nil {
			return fmt.Errorf("error reading 'receiver': %w", err)
		}
	}

	return err
}
